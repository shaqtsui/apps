Externally JPA act as a Resource Manager, it need external Transaction Manager to manage transactions


Concepts:
	Persistence Unit
		a set of all entity classes that are managed by EntityManager instances in an application.
		defined by a persistence.xml
		
	Persistence Context
		a set of managed entity instances that exist in a particular data store
		
	EntityManagerFactory
		associate to a Persistence Unit
		
	EntityManager
		associate to a Persistence Context


Locking
	An entity is automatically enabled for optimistic locking if it has a property or field mapped with a Version mapping.
	only the persistence provider is permitted to set or update the value of the version attribute in the object


JPA spec requires some type of monitoring of Entity objects, but the spec does not define how to implement this monitoring.
	Common Approaches to Impl this:
		auto-generate new subclasses or proxy objects that front the user's Entity objects at runtime (hibernate)
		byte-code weaving technologies to enhance the actual Entity class objects (at build-time or run-time)
			META-INF/persistence.xml should be used by weaving.
			For EclipseLink:
				I can see "[debug] execute contextualize" during build.


Persistence.createEntityManagerFactory(persistenceUnitName);
	Lookup & initial PersistenceProvider via SPI
	return PersistenceProvider.createEntityManagerFactory(persistenceUnitName, null);

--------------------------------------------------------------------------------------------------------------

U even no need to put <provider> in persistence.xml. 
U just need to put hibernate related jar files in the class path, 
because JPA will try to find & load all provider via SPI


Properties in persistence should always contains provider prefix. Ex: hibernate.
U can put all provider's property config in one persistence unit, so that
when u change provide(META-INF/services/javax.persistence.spi.PersistenceProvider), u no need to change the persistence.xml
This means that one persistence.xml can cater for all the providers without any changes.



Cache:
	L1 Cache - Persistence Context
		The collection of all the managed objects of an EntityManager
		Owned by EntityManager
	L2 Cache - Shared Cache
		Managed by the EntityManagerFactory and shared by all its EntityManager objects



mappedBy:
	The field that owns the relationship. Required unless the relationship is unidirectional(in DB)


Entity Relationship:
	In DB:
		Maintained in Row record, which can be maintained in Entity Table(OneToOne/ManyToOne) or separate Relationship Table(OneToMany)
	In Object:
		Maintained in Reference 

JPA Relations:
==========================================================================================

Class UserInfo
@OneToMany(mappedBy="userInfo")
private List<AddressInfo> addr;
	
Class AddressInfo
@ManyToOne
private UserInfo userInfo;	

Table
Hibernate: insert into AddressInfo (addressDetails, userInfo_id, id) values (?, ?, ?)
Hibernate: insert into AddressInfo (addressDetails, userInfo_id, id) values (?, ?, ?)
Hibernate: insert into UserInfo (email, name, id) values (?, ?, ?)

==========================================================================================

Class UserInfo
@OneToMany
private List<AddressInfo> addr;

Class AddressInfo
@ManyToOne
private UserInfo userInfo;	

Table
Hibernate: insert into AddressInfo (addressDetails, userInfo_id, id) values (?, ?, ?)
Hibernate: insert into AddressInfo (addressDetails, userInfo_id, id) values (?, ?, ?)
Hibernate: insert into UserInfo (email, name, id) values (?, ?, ?)
Hibernate: insert into UserInfo_AddressInfo (UserInfo_id, addr_id) values (?, ?)
Hibernate: insert into UserInfo_AddressInfo (UserInfo_id, addr_id) values (?, ?)

==========================================================================================

Class UserInfo
@OneToMany
private List<AddressInfo> addr;

Class AddressInfo
//@ManyToOne
//	private UserInfo userInfo;	

Table
Hibernate: insert into AddressInfo (addressDetails, id) values (?, ?)
Hibernate: insert into AddressInfo (addressDetails, id) values (?, ?)
Hibernate: insert into UserInfo (email, name, id) values (?, ?, ?)
Hibernate: insert into UserInfo_AddressInfo (UserInfo_id, addr_id) values (?, ?)
Hibernate: insert into UserInfo_AddressInfo (UserInfo_id, addr_id) values (?, ?)

==========================================================================================

Class UserInfo
@ManyToOne
private AddressInfo addr;

Class AddressInfo
//@OneToMany
//	private UserInfo userInfo;	

Table
Hibernate: insert into AddressInfo (addressDetails, id) values (?, ?)
Hibernate: insert into UserInfo (addr_id, email, name, id) values (?, ?, ?, ?)

==========================================================================================

GenerationType
	TABLE
		Generated by persist provider & saved in DB Table
			E.g.
				Hibernate generate hibernate_sequences to maintain this id
		Supported DB: All
		
	SEQUENCE
		use id generated by DB Sequence (created via : CREATE SEQUENCE XXXXX START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;)
		Supported DB: Oracle DB, PostgreSQL, IBM DB2 ver 7.2
		
	IDENTITY
		use id generated by DB IdentityColumn during insertion
		this need db table column to be created with auto generation enabled
		Supported DB: MySQL, Microsoft SQL Server, IBM DB2 ver 7.1 and later
		
	AUTO
		This is default strategy
		Typically, EclipseLink picks TABLE as the strategy